<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="css/style.css">
	<title>Поля, отступы, границы</title>
</head>
<body>
	<div class="container">
		<header class="header">
			<h1>Поля, отступы, границы</h1>
			<div class="header__menu">
				<ul class="header__menu-left">
					<li>
						<a class="menu__title" href="#block">Понятие блочной модели</a>
					</li>
					<li>
						<a href="#upravlenie">Управление размерами полей и отступов</a>
					</li>
					<li>
						<a href="#svoistva">Сокращенная запись свойств margin и paddin</a>
					</li>
					<li>
						<a href="#konflict">Конфликты полей</a>
					</li>
					<li>
						<a href="#udalenie">Удаление воздуха с помощью отрицательных значений</a>
					</li>
					<li>
						<a href="#otobragenie">Отображение строчных и блочных элементов</a>
					</li>
				</ul>
				<ul class="header__menu-right">
					<li>
						<a class="menu__title" href="#izmenenie">Изменение высоты и ширины</a>
					</li>
					<li>
						<a href="#razmeri">Вычисление фактических размеров блочных элементов</a>
					</li>
					<li>
						<a href="#korobka">Переопределение ширины блока  с помощью свойства box-sizing</a>
					</li>
					<li>
						<a href="#znachenie">Задание максимальных  и минимальных значений  высоты и ширины</a>
					</li>
				</ul>
			</div>
			<div class="header__text">
				<p>На любой HTML-<span class="pfd">элемент </span>воздействует множество свойств каскадных таблиц стилей, определяющих, каким образом он будет отображен браузером. Некоторые из них, например границы и фоновый цвет, наглядны. Другие нельзя определить явно (например, отступы и поля), но они также обеспечивают форматирование. Понимая, как эти атрибуты работают, вы можете создать привлекательные колонки, меню, <span class="pfd">элементы</span> навигации, а также управлять пространством вокруг них (вебдизайнеры называют его воздухом). Это делается для того, чтобы ваши веб-страницы не казались беспорядочными и нечитаемыми и вообще выглядели профессионально. </p>
				<p>Все свойства, описываемые в текущей главе, — основа <span class="pfd">блочной модели</span> CSS, которая представляет одну из важнейших составляющих этого языка.</p>
			</div>
		</header>
	</div>
	<div class="container">
		<div class="wrapper">
			<div class="block">
				<h2 id="block" class="block__title">Понятие блочной модели</h2>
				<div class="block__content">
					<p>Когда вам говорят об абзаце текста или заголовке, вы представляете буквы, слова, предложения. Фотографии, логотипы и другие изображения должны ассоциироваться с элементом <span class="pfd">img</span>. Браузер обрабатывает все элементы как небольшие блоки. Для него любой элемент — контейнер с содержимым: текстом, изображением или другими элементами (рис. 7.1). Область внутри границ, которая включает контент и отступы, может также иметь цвет фона. Он находится под границей, поэтому, когда вы используете пунктирную или точечную границу, цвет отображается в промежутках между отрезками или точками.</p>	
					<ul class="block__list">
						<li class="menu__title">Блок элемента окружают следующие свойства. </li>
						<li><span class="line">padding</span> — <span class="pfd">отступ</span>, пространство между контентом и границей. </li>
						<li><span class="line">border </span> — <span class="pfd">граница</span>, линия вдоль каждого края блока. Граница может отображаться как для всех сторон сразу, так и для любой из них или комбинации сторон. </li>
						<li><span class="line">margin </span> — <span class="pfd">поле</span>, отделяет один элемент от другого. К примеру, пространство, обычно отображаемое сверху и снизу абзацев текста, — это поля.</li>
					</ul>
					<div class="block__image">
						<img src="img/block-1.jpg" alt="картинка-1">
						<img src="img/block-2.jpg" alt="картинка-2">
						<p>Рис. 7.1. Блочную структуру элемента образует его содержимое (например, несколько предложений текста), а также отступы, границы и поля</p>
					</div>
					<p>Для форматирования элемента можно использовать любые из этих свойств в любом сочетании или все сразу. Вы можете снабдить элемент исключительно полями или же добавить границы, поля и отступы. Или элемент может иметь границы и отступ, но без полей и т. д. Если вы не настроите какое-либо из этих свойств, то браузер применит собственные настройки, которые вам могут как понравиться, так и нет. К примеру, хотя браузеры обычно не применяют отступы или границы к элементам на странице, некоторые элементы (например, заголовки и абзацы) имеют верхнее и нижнее поле. </p>
					<div class="content-sovet">
						<p class="sovet__title"><mark>Совет</mark></p>
						<p>Поскольку разные браузеры применяют отступы и поля разного размера, лучше всего сбрасывать значения этих свойств для всех элементов. Другими словами, используйте набор простых стилей, отвечающих за сброс CSS, для удаления отступов и полей из HTML-элементов. Потом, когда вы будете создавать дополнительные стили, добавляющие поля и отступы, вы сможете быть уверены в том, что страницы будут выглядеть одинаково в разных браузерах. </p>
					</div>
				</div>
			</div>
			<div class="control">
				<h3 id="upravlenie" class="control__title">Управление размерами полей и отступов </h3>
				<div class="control__content">
					<p>Как поля, так и отступы добавляют промежутки вокруг содержимого элементов. Свойства margin и padding используются для отделения одного элемента веб-страницы от другого. Можно применять их, например, чтобы добавить пустое пространство между панелью навигации слева и основным контентом веб-страницы справа. Возможно, вы захотите отодвинуть границу от края фотографии (рис. 7.2). На рис. 7.2 отступ разделяет два изображения друг от друга с помощью серого фона. Вы можете устанавливать границы, поля для каждой стороны изображения независимо друг от друга. Обратите внимание, что для нижних краев (оснований) фотографий установлены большие по размеру отступы, чем для остальных.</p>	
					<div class="control__image">
						<img src="img/sizing-1.jpg" alt="картинка-3">
						<p> Рис. 7.2. Каждая фотография на этой веб-странице имеет поле размером 10 пикселов, то есть промежуток, отделяющий две соседние фотографии, составляет 20 пикселов</p>
					</div>
						<p>Свойства <span class="pfd">padding и margin</span> производят одинаковый визуальный эффект, и, пока вы не добавите границу или цвет фона, вы не сможете сказать наверняка, каким свойством определен этот промежуток. Но если элемент имеет границу по периметру или цветной фон (подложку), вы заметите существенное различие этих свойств. Отступ добавляет промежуток между контентом и границей элемента и предотвращает появление эффекта заключения содержимого элемента в рамку. Он также включает область фона, поэтому пространство, занимаемое отступом, может быть свободно от содержимого (текста или фотографии), но заполнено фоновым цветом или изображением. А поля добавляют так называемые средники — промежутки между колонками, которые придают веб-странице более «воздушный» внешний вид. </p>
						<p>Вы можете управлять полями или отступами каждого отдельного элемента независимо. Четыре свойства управляют соответствующими полями с каждой стороны элемента: <span class="pfd">margin-top, margin-right, margin-bottom и margin-left</span>. Аналогично с отступами: <span class="pfd">padding-top, padding-right, padding-bottom и padding-left</span>. Вы можете использовать любые единицы измерения, принятые в языке CSS, для определения размеров полей и отступов, например: </p>		
						<p class="text">margin-right: 20px; padding-top: 3em; margin-left: 10%; </p>
						<P>Пикселы и единицы em применяются и работают точно так же, как при форматировании текста (см. раздел «Изменение размера шрифта» главы 6). Поле размером 20 пикселов добавляет соответствующий пустой промежуток, отступ 3 em — промежуток, в три раза больший, чем размер шрифта форматируемого элемента. </P>
						<p>Обычно используются значения в процентах. С их помощью можно гибко задавать значения границ и отступов, которые будут зависеть от ширины окна браузера, что идеально подходит для адаптивного дизайна. </p>
					<div class="content-sovet">
						<p class="sovet__title"><mark>Совет</mark></p>
						<p>Чтобы удалить все пространство полей и отступов, используйте свойства со значением 0 (например, margin-top: 0 или padding-bottom: 0). Чтобы убрать все дополнительное пустое пространство с четырех сторон окна браузера, нужно присвоить свойствам margin и padding нулевые значения: margin: 0; padding 0;. Это позволит поместить баннер, заголовок, логотип или какой-то другой элемент веб-страницы вплотную у самого края окна браузера, без промежутков.
						</p>
					</div>
					<div class="control__imag scroll">
						<img src="img/sizing-2.jpg" alt="картинка-4">
						<img src="img/sizing-3.jpg" alt="картинка-5">
					</div>
				</div>
			</div>
			<div class="features">
				<h3 id="svoistva" class="features__title">Сокращенная запись свойств margin и padding</h3>
				<div class="features__content">
					<p>Нередко требуется одновременно установить одинаковые размеры полей или отступов для всех четырех сторон форматируемого элемента. Но последовательно набирать четыре различных свойства стиля (<span class="pfd">margin-right, margin-left</span> и т. д.) утомительно и отнимает лишнее время. Здесь вы также можете использовать сокращенные варианты свойств <span class="pfd">margin и padding</span> для быстрой установки всех четырех параметров одновременно: </p>
					<p class="features__text">margin: 0 10px 10px 20px; padding: 10px 5px 5px 10px;
					</p>
					<div class="content-sovet">
						<p class="sovet__title"><mark>Совет</mark></p>
						<p>Если свойству присваивается значение 0, то совсем не нужно указывать единицу измерения. Например, наберите всего лишь margin: 0; вместо margin: 0px;.
						</p>
					</div>
					<p>Порядок определения четырех значений свойств <span class="pfd">margin и padding</span> важен. Они должны указываться в следующей последовательности: сверху, справа, снизу и cлева. Без учета этого у вас могут возникнуть проблемы с форматированием. Самый легкий способ запомнить очередность — сверху вниз по часовой стрелке. Если вы хотите применить одинаковое значение свойства для всех четырех сторон, нет ничего проще — используйте единственное значение. Чтобы удалить все поля из заголовка h1, добавьте такой стиль: </p>
					<p class="features__text">h1 {  margin: 0; } </p>
					<p>Кроме того, пользуйтесь сокращенной записью для добавления промежутков между содержимым и границами элемента: </p>
					<p class="features__text">padding: 10px;</p>
					<div class="content-sovet">
						<p class="sovet__title"><mark>Совет</mark></p>
						<p>Если нужно применить одинаковое значение свойства поля или отступа сверху и снизу элемента и одно и то же значение для левого и правого края, можно указать два значения. Так, объявление margin: 0 2em; удаляет верхнее и нижнее поля, а левое и правое поля устанавливает равными 2 em. Точно так же, если верхние и нижние поля (или отступы) изменяются, а правые и левые остаются прежними, можно воспользоваться тремя значениями. Например, объявление margin: 0 2em 1em; установит верхнее поле равным 0, левое и правое — равными 2 em, а нижнее поле — 1 em.
						</p>
					</div>
				</div>
			</div>
			<div class="conflict">
				<h3 id="konflict" class="conflict__title">Конфликты полей</h3>
				<div class="conflict__content">
					<p>В каскадных таблицах стилей не всегда справедливы математические расчеты. Вы сами можете в этом убедиться, когда нижнее поле одного элемента веб-страницы касается верхнего поля другого элемента. Вместо того чтобы объединить эти поля вместе, браузер использует большее из них (рис. 7.3, вверху). Предположим, значение нижнего поля маркированного списка установлено равным 30 пикселам, а значение верхнего поля следующего за ним абзаца составляет 20 пикселов. Вместо того чтобы сложить два значения, получив общий промежуток в размере 50 пикселов между списком и абзацем, браузер применяет наибольшее из двух значений — в данном случае 30 пикселов. Если вас такое поведение не устраивает, используйте вместо полей верхний или нижний отступ (см. рис. 7.3, внизу).
					</p>
					<div class="conflict__image">
						<img src="img/conflict-1.jpg" alt="картинка-6">
						<p>Рис. 7.3. При соприкосновении двух вертикальных полей меньшее из них игнорируется
						</p>
					</div>
					<p>На рис. 7.3, несмотря на то что и верхний заголовок имеет нижнее поле в размере 20 пикселов, а у расположенного ниже абзаца текста верхнее поле составляет 15 пикселов, браузер добавляет промежуток между ними, равный всего 20 пикселам. Чтобы получить тот промежуток, который вы хотели (35 пикселов), используйте вместо полей отступы, как показано в нижней части рисунка. Здесь для заголовка установлен нижний отступ 20 пикселов. Он складывается с верхним полем абзаца, равным 15 пикселам, и получается общий промежуток в размере 35 пикселов. </p>
					<p>Ситуация еще более усугубляется, когда один элемент веб-страницы <span class="pfd">вложен</span> в другой. Это может привести к затиранию отдельных частей. Допустим, вы добавляете на веб-страницу «предупреждение» (заключенное в элемент div). Верхнее и нижнее поля устанавливаются равными 20 пикселам, чтобы отделить сообщение от заголовка сверху и от абзаца текста снизу. Пока все выглядит неплохо</p>
					<p>Но, предположим, вы вставляете заголовок в сообщение с предупреждением и, чтобы добавить небольшой промежуток между сообщением и верхним и нижним краем блока div, определяете для заголовка поле размером 10 пикселов. Вы, наверное, думаете, что добавили 10-пиксельный промежуток, но вы не правы (рис. 7.4, <span class="pfd">вверху</span>). Вместо этого поле появляется <span class="pfd">над</span> блоком div. В данном случае не имеет значения, какого размера поле применяется к заголовку, — поле все равно окажется над div.
					</p>
					<div class="conflict__image">
						<img src="img/conflict-2.jpg" alt="картинка-7">
						<p>Рис. 7.4. Как бы ни соприкасались вертикальные поля, в любом случае произойдет конфликт
						</p>
					</div>
					<div class="content-sovet">
						<p class="sovet__title"><mark>Совет</mark></p>
						<p>На профессиональном жаргоне CSS это явление называется схлопыванием полей. Оно означает, что два поля фактически превращаются в одно.</p>
					</div>
					<p>Есть два пути решения этой проблемы: добавить либо небольшой отступ, либо границу вокруг элемента div. Поскольку между этими двумя полями располагаются граница и отступ, поля больше не схлопываются и заголовок имеет небольшой отделяющий промежуток (см. рис. 7.4, внизу). </p>
					<div class="content-sovet">
						<p class="sovet__title"><mark>Совет</mark></p>
						<p>Горизонтальные (слева и справа) поля и поля между плавающими элементами не схлопываются. Между абсолютно и относительно позиционируемыми элементами, о которых вы узнаете в главе 13, также нет конфликта.</p>
					</div>
				</div>
			</div>
			<div class="delete">
				<h3 id="udalenie" class="delete__title">Удаление воздуха с помощью отрицательных значений </h3>
				<div class="delete__content">
						<p>Большинство значений свойств в CSS должны быть положительными. Что же произойдет, если указать для размера шрифта текста отрицательное значение, например <span class="pfd">минус 20 пикселов</span>? Вообще, отступы должны иметь положительные значения. Однако каскадные таблицы стилей допускают использование отрицательных значений для создания определенных визуальных эффектов. Отрицательные значения полей вместо добавления пустого пространства между тем или иным элементом и соседними, наоборот, вызывают удаление этих промежутков. В результате может получиться абзац, накладывающийся на заголовок, выступающий из своего элемента-контейнера (боковой панели или другого элемента div) или даже совсем исчезающий за пределами окна браузера. Таким образом, можно с уверенностью сказать, что применение отрицательных значений полей дает немалую пользу. </p>
						<p>Отрицательные значения полей вместо добавления пустого пространства между тем или иным элементом и соседними, наоборот, вызывают удаление этих промежутков. В результате может получиться абзац, накладывающийся на заголовок, выступающий из своего элемента-контейнера (боковой панели или другого элемента div) или даже совсем исчезающий за пределами окна браузера. Таким образом, можно с уверенностью сказать, что применение отрицательных значений полей дает немалую пользу. </p>
						<p>Даже когда вы устанавливаете размеры полей, равные 0, между двумя заголовками, все равно остается небольшой промежуток (благодаря межстрочному интервалу, как описано в подразделе «Установка межстрочного интервала» раздела «Форматирование абзацев» главы 6). На самом деле это не так уж плохо, поскольку трудно читать предложения без дополнительных интервалов, сливающиеся друг с другом. Тем не менее разумное, умеренное использование небольших промежутков между заголовками поможет создать интересные визуальные эффекты. Второй заголовок на рис. 7.5 (который начинается со слов Raise Tuna) имеет верхнее поле размером 10 пикселов. Оно поднимает заголовок вверх, что обеспечивает небольшое наложение текста на пространство вышестоящего заголовка. Кроме того, левые и правые границы заголовка, начинающегося со слов Extra! Extra!, теперь соприкасаются с буквами большего заголовка, создавая эффект единой надписи. </p>
						<p>Можно также использовать отрицательные значения полей для того, чтобы имитировать отрицательный отступ. В третьем заголовке на рис. 7.5, который начинается со слов The Extraordinary Technique, линия подчеркивания отображена прямо под текстом. Она на самом деле представляет собой верхнюю границу следующего абзаца (о том, как к тексту добавить границы, вы узнаете далее). Но, поскольку здесь определена верхняя граница с отрицательным значением, она располагается чуть выше текста абзаца и фактически находится под верхним заголовком. Обратите внимание на то, что хвост буквы Q заголовка буквально свисает под линией-границей. Поскольку отступ между содержимым (то есть Q) и границей не может быть отрицательным, вам не удастся поднять нижнюю границу так, чтобы она находилась ближе к тексту или любому другому содержимому, не говоря уже о наложении. И все же есть возможность добиться этого эффекта, применив границу с отрицательным значением к последующему, нижестоящему элементу веб-страницы. </p>
					<div class="content-sovet">
						<p class="sovet__title"><mark>Совет</mark></p>
						<p>Можно использовать либо верхнее поле абзаца с отрицательным значением, либо отрицательное нижнее поле заголовка. Оба варианта приведут к одному и тому же визуальному эффекту поднятия абзаца выше, ближе к тексту заголовка.</p>
					</div>
				</div>
			</div>	
			<div class="visible">
				<h3 id="otobragenie" class="visible__title">Отображение строчных и блочных элементов</h3>
				<div class="visible__content">
					<p>Хотя браузеры и обрабатывают любой тег веб-страницы подобно блочному элементу, на самом деле они не все одинаковы. В CSS существует два различных типа элементов: <span class="pfd">блочные и строчные</span>. </p>
					<p>В <span class="pfd">блочных</span> элементах создается разрыв строки перед элементом и после него. Например, абзац <span class="pfd">p</span> создает блок, отделенный от элементов, расположенных выше и ниже его. Другими примерами являются заголовки, контейнеры <span class="pfd">div</span>, таблицы, списки и элементы списков.</p>
					<p><span class="pfd">Строчные </span>элементы не создают разрывов строк ни до, ни после себя. Они отображаются на одной строке с содержимым рядом стоящих элементов. Элемент <span class="pfd">strong</span> — строчный. Слово, отформатированное с его помощью, будет расположено на одной строке с текстом, заключенным в другие строчные элементы, например em. Было бы очень странно, если бы отдельное слово в середине абзаца, выделенное<span class="pfd"> strong</span>, вдруг появилось на отдельной строке. Другими примерами строчных элементов являются <span class="pfd">img</span> — для добавления изображений, <span class="pfd">a</span> — для создания ссылок, различные элементы для разметки форм и т. д. </p>
					<p>В большинстве случаев каскадные таблицы стилей одинаково работают со строчными и блочными элементами. Можно применять шрифты, цвет, фон, границы к обоим типам элементов. Однако поля и отступы строчных элементов браузеры обрабатывают по-другому. Если добавить поля или отступы слева или справа строчного элемента, то посредством установки верхнего или нижнего отступа или поля увеличить высоту строчного элемента не удастся. В верхнем абзаце на рис. 7.6 строчный элемент отформатирован с применением границ, фонового цвета и полей размером 20 пикселов со всех четырех сторон. Но браузер добавляет пустые промежутки только с левой и правой стороны элемента.</p>
					<div class="visible__image">
						<img src="img/visible.jpg" alt="картинка-8">
						<p>Рис. 7.6. Добавление к строчному элементу верхнего, нижнего поля или отступа не изменит высоту элемента: форматирование будет не таким, как вы ожидаете.
						</p>
					</div>
					<p>На рис. 7.6 в среднем абзаце фон и границы ссылки накладываются на текст, находящийся выше и ниже форматируемого. Цвет фона строчного элемента отображается поверх вышестоящей строки текста, но под следующей, так как браузер обрабатывает каждую строку так, будто она расположена в стеке, наверху по отношению к предыдущей. Как правило, это не представляет проблемы, поскольку строки текста обычно не накладываются. Если вы хотите, чтобы верхние и нижние поля были применимы к строчному элементу, используйте инструкцию <span class="pfd">display:inlineblock</span> (внизу). Она оставит элемент строчным, но он будет восприниматься как блочный, поэтому отступы, поля, границы, ширина и высота будут к нему применимы. </p>
					<div class="content-sovet">
						<p class="sovet__title"><mark>Совет</mark></p>
						<p>Есть одно исключение из этого правила: если поля или отступы применяются к строчным элементам img, элементы не изменяют своей высоты. Браузеры корректно меняют высоту контейнера элемента-изображения, чтобы подогнать указанные отступы и поля.
						</p>
					</div>
					<p>Иногда требуется, чтобы строчные элементы вели себя так же, как блочные, или наоборот. Маркированные списки представляют элементы в виде отдельных блоков, то есть каждый элемент списка располагается в стеке поверх следующего. Но что делать, если вы хотите изменить поведение пунктов списка таким образом, чтобы все они располагались рядом друг с другом, на одной строке (как панель навигации, показанная на рис. 9.4)? Или, возможно, вы захотите, чтобы строчный элемент обрабатывался как блочный, например, изображение, встроенное в абзац текста, было расположено на отдельной строке, с верхним и нижним промежутками-интервалами. </p>
					<p>В языке CSS есть команда, которая позволяет вам это сделать, — это свойство <span class="pfd">display</span>. С его помощью можно заставить блочный элемент функционировать как строчный: </p>
					<p class="visible__text">display: inline;</p>
					<p>Или, наоборот, вы можете сделать так, чтобы строчные элементы, например изображение или ссылка, вели себя как блочные: </p>
					<p class="visible__text">display: block; </p>
					<p>Наконец, вы можете заставить элемент действовать и как блочный, и как строчный. Значение inline-block не создает разрывов ни до, ни после элемента и одновременно заставляет элемент подчиняться верхним и нижним полям и отступам, а также настройкам высоты: </p>
					<p class="visible__text">display: inline-block; </p>
					<div class="content-sovet">
						<p class="sovet__title"><mark>Совет</mark></p>
						<p>ЕУ свойства display есть большое количество значений, многие из которых поддерживаются не всеми браузерами. Значение inline-block поддерживается во всех современных браузерах (см. рис. 7.6). Другое значение — none — обрабатывается в большинстве браузеров и имеет множество вариантов использования. Это значение выполняет одну простую функцию — полностью скрывает форматируемый элемент, чтобы он не отображался в окне браузера. Используя JavaScript-сценарии, вы можете скрыть элементы, чтобы они стали видимыми после присваивания свойству display значения inline или block. Сделать их видимыми можно и средствами каскадных таблиц стилей.
						</p>
					</div>
				</div>
			</div>
		</div>
	</div>
	<div class="container">
		<div class="wrapper">
			<div class="change">
				<h2 id="izmenenie" class="change__title">Изменение высоты и ширины</h2>
				<div class="change__content">
					<p>Рассмотрим еще два свойства, являющихся частью блочной модели CSS. Они предназначены для установки размеров объектов, таких как таблица, колонка, баннер, боковая панель. Свойства height и width определяют высоту и ширину области форматируемого элемента. Мы будем часто пользоваться ими при создании разметки, макета веб-страниц, как описано в части III. Они также применяются для разработки базового дизайна: назначения ширины таблиц, создания простейших боковых панелей или галерей эскизов. </p>
					<p>Разработка стилей с этими свойствами не составляет сложностей. Наберите их со значением в любой единице измерения языка CSS, которые мы изучили. Например: </p>
					<p class="change__text">width: 300px; width: 30%; height: 20em;</p>
					<p>Пикселы просты в использовании, понятны и удобны, обеспечивают точные ширину или высоту. Единица измерения em — это примерно то же самое, что и размер шрифта текста. Допустим, вы устанавливаете размер шрифта 24 пиксела; единица em для этого форматируемого элемента будет равна 24 пикселам, а если вы установите ширину равной 2 em, она составит 2 × 24 или 48 пикселов. Если вы не определите в стиле размер шрифта текста, то он будет взят из унаследованных параметров. </p>
					<p>Процентные значения свойства width рассчитываются на основании ширины элемента-контейнера. Если вы установите ширину заголовка равной 75 % и этот заголовок не вложен ни в какие другие элементы веб-страницы с явно определенной шириной, то ширина заголовка составит 75 % от ширины окна браузера. Если посетитель изменит размер окна браузера, то ширина заголовка тоже изменится. Однако если заголовок заключен в блок div шириной 200 пикселов (к примеру, для создания колонки), то ширина этого заголовка составит 150 пикселов. Процентные значения в свойстве height работают точно так же, но расчет базируется на высоте элемента-контейнера, а не на его ширине.
					</p>
				</div>
			</div>
			<div class="calculation">
				<h3 id="razmeri" class="calculation__title">Вычисление фактических размеров блочных элементов</h3>
				<div class="calculation__content">
					<p>Свойства <span class="pfd">width и height</span> на первый взгляд кажутся довольно простыми и понятными, однако есть несколько нюансов, вводящих начинающих веб-дизайнеров в заблуждение. Прежде всего, существует различие между значениями ширины и высоты, которые вы явно указываете при написании стилей, и размером пространства, которое браузер фактически выделяет и использует для отображения элементов блочной модели CSS. Свойства<span class="pfd"> width и height</span> устанавливают ширину и высоту <span class="pfd">области</span> содержимого форматируемого элемента — пространства, в котором заключены текст, изображения или другие вложенные элементы (см. рис. 7.1, чтобы вспомнить о том, где именно в блочной конструкции элементов CSS находится область содержимого</p>
					<p>Фактическая ширина элемента веб-страницы представляет собой область экрана (окна браузера), выделяемую для отображения. Она состоит из ширины полей, границ, отступов и явно указанного значения ширины в свойстве стиля, как показано на рис. 7.12.
					</p>
					<div class="calculation__image">
						<img src="img/calculation.jpg" alt="картинка-9">
						<p>Рис. 7.12. Фактическая ширина блока форматируемого элемента вычисляется путем сложения значений свойств margin, border, padding и width. Высота экранного элемента рассчитывается исходя из суммы значения свойства height, верхних и нижних полей,  верхней и нижней границ и верхнего и нижнего отступа
						</p>
					</div>
					<p>Допустим, вы назначили следующие свойства:</p>
					<p class="calculation__text">width: 100px; padding: 15px; border-width: 5px; margin: 10px;</p>
					<p>Если определено свойство <span class="pfd">width</span>, вы всегда точно знаете, сколько места займет содержимое элемента — текст и изображения, заполняющие основное пространство элемента, — независимо от любых других установленных свойств. Вам не нужно ничего вычислять, потому что значение<span class="pfd"> width</span> и есть размер основного пространства для размещения содержимого (в представленном выше примере ширина равна 100 пикселам). Конечно, <span class="pfd">придется</span> выполнить несложные арифметические операции, чтобы выяснить общий точный размер. В представленном выше примере для размещения форматируемого элемента отводится пространство шириной 160 пикселов: 20 пикселов для левого и правого полей, 10 — для левой и правой границ, 30 — для левого и правого отступа и 100 пикселов в качестве ширины основного содержимого. </p>
					<p>Общее правило по регулированию высоты элементов на странице гласит так: не делайте этого! Многие подающие надежды веб-дизайнеры пытаются задать высоту абсолютно для всего, желая получить полный контроль над пикселами. </p>
					<p>Но если вы полностью не уверены в точных размерах содержимого внутри элемента, то можете столкнуться с некоторыми нежелательными результатами (рис. 7.13). В этом примере блок с цитатой, который используется для того, чтобы акцентировать внимание на интересном отрывке из статьи, имеет ширину и высоту 100 пикселов. Когда в блок добавляется больше текста, чем может уместиться в такую высоту, его содержимое выходит за пределы. Даже если вы уверены, что текст, который вы разместили в блоке с фиксированной высотой, соответствует его размерам, посетитель может увеличить размер шрифта в своем браузере и высота текста, соответственно, станет больше высоты блока. </p>
					<p>Другими словами, свойство <span class="pfd">height</span> полезно для контроля высоты элемента d<span class="pfd">iv</span>, содержащего, например, изображения, потому что в таком случае вы можете правильно определить его высоту. Однако если вы используете это свойство для элементов с текстом, не забудьте не только протестировать свои страницы в основных браузерах, но и проверить их при различных установленных размерах шрифта, изменяя его в браузерах.
					</p>
					<div class="content-sovet">
						<p class="sovet__title"><mark>Совет</mark></p>
						<p>Область баннера на странице — еще один подходящий кандидат для установки высоты. Обычно баннер имеет ограниченное содержимое: логотип, поле поиска, может быть, какие-нибудь навигационные кнопки. Зачастую у баннеров остается довольно много пустого пространства (помогающего привлечь внимание посетителя к ключевым элементам навигационной панели), поэтому указание высоты для баннера обычно не вызывает проблем.
						</p>
					</div>
				</div>
			</div>
			<div class="box">
				<h3 id="korobka" class="box__title">Переопределение ширины блока  с помощью свойства box-sizing</h3>
				<div class="box__content">
					<p>Как уже упоминалось, браузеры традиционно вычисляют ширину элемента, складывая значения свойств border, padding и width. Это не только заставит вас проводить математические вычисления, чтобы определить реальную ширину отображаемого элемента, но и может вызвать ряд других проблем. Особенно это касается случаев создания макетов с плавающими элементами с использованием процентных отношений. Подробности создания макетов с плавающими элементами нам еще предстоит изучить, но если говорить вкратце, каскадные таблицы стилей позволяют с помощью свойства float помещать элементы бок о бок, что дает возможность создавать разметки, состоящие из нескольких колонок. </p>
					<p>Когда для нескольких колонок используется процентное отношение, могут возникать довольно странные проблемы. Предположим, есть две колонки (на самом деле два таких элемента, как div) и нужно, чтобы каждая занимала 50 % ширины окна. Соответственно, для двух колонок устанавливается ширина 50 %, но на тот момент, когда добавляется отступ или граница к одной из колонок, вы увеличиваете ее ширину, которая становится больше 50 % (если точнее, она составляет 50 % плюс значение левого и правого отступов и значение ширины левой и правой границ). В большинстве случаев это заставит вторую колонку опуститься ниже первой. </p>
					<p>На этот случай каскадные таблицы стилей предлагают свойство, позволяющее изменить порядок вычисления браузером экранной ширины (и высоты) элемента. Свойство box-sizing предоставляет три варианта. </p>
					<ul class="box__list">
						<li> <span class="pfd">content-box</span> устанавливает ранее рассмотренный способ, с помощью которого браузеры всегда определяют экранную ширину и высоту элемента. То есть браузер добавляет ширину границ и толщину отступа к значениям, установленным для свойств ширины и высоты, чтобы определить экранную ширину и высоту заданного элемента. Поскольку это поведение используется по умолчанию, указывать что-либо для реализации варианта content-box не нужно. </li>
						<li> <span class="pfd">padding-box</span> сообщает браузеру, что при установке для стиля свойства ширины или высоты они должны включать отступы как часть своего значения. Предположим, что есть элемент с отступами слева и справа, равными 20 пикселам. Его ширина установлена равной 100 пикселам. Браузер будет рассматривать ту часть, что приходится на отступы, частью этого 100-пиксельного значения. То есть ширина области содержимого будет равна всего лишь 60 пикселам (100 — 20 [левый отступ] — 20 [правый отступ]). </li>
						<li><span class="pfd">border-box</span> сообщает браузеру о необходимости включения в качестве составляющей части значений свойств width и height толщину как отступа, так и границ. Эта настройка решает ту проблему использования значений, выраженных в процентном отношении, о которой говорилось выше. То есть когда свойству box-sizing присвоено значение border-box, при установке ширины элемента, равной 50 %, этот элемент будет занимать до 50 % пространства, даже если к нему будут добавлены отступы и границы.</li>
					</ul>
					<p>Если вам не нравится стандартный способ вычисления браузером элементов ширины и высоты, добавьте значение <span class="pfd">border-box</span>. (Если, конечно, у вас нет какойнибудь причины, по которой вы хотите включить в расчеты отступ, но не хотите включать туда еще и границу.) Чтобы воспользоваться свойством <span class="pfd">box-sizing</span>, предоставьте ему одно из трех значений из списка. Например:</p>
					<p class="box__text">box-sizing: border-box; </p>
					<p>Между прочим, многие веб-разработчики настолько оценили пользу настройки <span class="pfd">border-box</span>, что создали универсальный селектор, применяемый к каждому элементу на странице</p>
					<p class="box__text">* {  box-sizing: border-box; } </p>
				</div>
			</div>
			<div class="maximum">
				<h3 id="znachenie" class="maximum__title">Задание максимальных  и минимальных значений  высоты и ширины </h3>
				<div class="maximum__content">
					<p>Если вы еще не поняли, хочу вас заверить, что каскадные таблицы стилей предлагают множество гибких решений. Кроме стандартных свойств width и height, можно воспользоваться еще четырьмя их вариантами. </p>
					<ul class="maximum__list">
						<li>Свойство <span class="pfd">max-width </span>устанавливает максимальную ширину элемента. Этот элемент может быть уже установленного предела, но не может быть шире. Такой вариант пригодится в том случае, когда нужно, чтобы ваша страница меняла свои размеры, чтобы поместиться на экранах разной ширины, но при этом нужно, чтобы она не становилась настолько широкой, что это затруднит ее чтение на мониторах с большой диагональю. Предположим, на страницу добавлен следующий стиль: <span>body {  max-width: 1200px; }</span>
						<p>Этот стиль позволяет странице перестраивать контент, чтобы поместиться по ширине на небольших экранах смартфонов или планшетных компьютеров. Но на действительно больших настольных мониторах страница не должна быть шире 1200 пикселов, то есть она не может разрастаться в ширину, при которой ее контент уже невозможно читать</p> 
						</li>
						<li>Свойство <span class="pfd">min-width </span>устанавливает минимальную ширину элемента. Элемент может растянуться шире значения минимальной ширины, но никогда не может стать уже этого значения. Если, к примеру, вы заметили, что при изменении размеров окна вашего браузера элементы становятся настолько узкими, что макет рассыпается, можно с помощью следующего кода установить ограничение минимальной ширины элемента: <span>body {  min-width: 760px; }</span> 
						<p>Если посетитель уменьшит окно своего браузера менее чем до 500 пикселов по ширине, браузер добавит полосу прокрутки, не сужая элементы на странице до крайности. <p></li>
						<li>Свойство <span class="pfd">min-height</span> работает точно так же, как и<span class="pfd"> min-width</span>, но применительно к высоте. Оно позволяет решить проблему, показанную на рис. 7.13. Ограничивая минимальную высоту, вы заставляете браузер сделать элемент по крайней мере имеющим определенную высоту. Если содержимое элемента выше, то браузер сделает выше весь элемент.</li>
						<li>Свойство <span class="pfd">min-height</span> работает точно так же, как и<span class="pfd"> min-width</span>, но применительно к высоте. Оно позволяет решить проблему, показанную на рис. 7.13. Ограничивая минимальную высоту, вы заставляете браузер сделать элемент по крайней мере имеющим определенную высоту. Если содержимое элемента выше, то браузер сделает выше весь элемент.</li>
					</ul>
				</div>
			</div>
		</div>
	</div>
</body>
</html>


